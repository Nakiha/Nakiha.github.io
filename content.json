{"pages":[],"posts":[{"title":"OSI七层模型","text":"本文参考自 百度百科 和 钛白Logic 的CSDN博客 1.概念OSI模型 = Open System Interconnection Reference Model译名为 开放式互联网通信参考模型 一般称作 OSI参考模型 它由 ISO组织提出, 是一个试图使各种计算机, 在世界范围内互联为网络的标准框架 2.OSI七层模型OSI模型从 硬件 到 应用 依次为:物理层 -&gt; 数据链路层 -&gt; 网路层 -&gt; 传输层 -&gt; 会话层 -&gt; 表示层 -&gt; 应用层 3.各层基本定义鉴于用户是从应用层使用 OSI模型此处从上到下对模型进行概述 3.1 应用层 Application Layer负责提供为应用软件建立的接口, 设置于另一应用软件的通信 确定进程之间通信的性质以满足用户的需要。 HTTP, HTTPS, FTP, SSH… 3.2 表达层 Persentation Layer负责实现数据向合适格式的转换, 提供数据对接收者的系统的兼容同时该层也可提供对数据的 压缩与加密 3.3 会话层 Session Layer负责在数据传输途中, 建立, 管理和终止表达层 相应的 通信连接该层中有不同应用程序的 服务请求和响应 3.4 传输层 Transport Layer负责给数据添加传输表头 (TH), 将数据打成数据包, 表头中含有所使用的协议等发送信息建立了源端与目的端的连接, 为上层提供可靠透明的传输服务, 同时屏蔽了更下层传输的细节 解决进程间的通信。 TCP, UDP… 3.5 网络层 Network Layer (IP 协议层)负责决定数据的路径选择和转寄, 添加网络表头 (NH)到数据包, 表头中含有网络数据,例如IP. 可用于形成分组 解决跨网络的主机通信问题。 IP(互联网协议) 3.6 数据链路层 Data Link Layer负责网络寻址, 差错校验. 添加数据链表头 (DLH) 和 数据链表尾 (DLT)到数据包中, 形成帧 解决相邻主机通信问题。 数据链表头 包含了物理地址和错误侦测及改错的方法 数据链表尾 包含了一串用于指示数据包末端的字符串 3.6.1此层包含两个子层 逻辑链路控制 LLC (Logic Link Control) 介质访问控制 MAC (media access control) MAC子层处理 CSMA/CD 算法, 数据出错校验, 成帧等 3.7 物理层 Physical Layer负责实现信号的具体化, 落实计算机通信的现实存在 透明地传输比特流。 4.通信特点: 对点通信源端的每一层都与目的端的对等层进行通信在每层通信过程中, 使用本层协议进行通信","link":"/2019/04/30/OSI七层模型/"},{"title":"又遇四大组件","text":"契机​ 做app的时候一直感觉力不从心, 总是掉入只见树木不见森林的误区里. 零零散散学的Android现在回忆起来的知识点也是零零散散, 需要开始系统化地学习了. ​ 花了点钱加入了Android方面的大牛玉刚的知识星球, 用Hexo架了这个博客, 希望能激励我学习, 并且记录下我的学习历程. ​ 从今天开始, Android Learning RESTART ! 新词汇积累 be bound to 绑定 Each activity is only loosely bound to the other activities foreground 前台 Activity or dialog appears in foreground transition 过渡 The activity transitions through the a series of callbacks functionality 功能 Supply functionality for other applications to use ActivityActivitiy是 Android app 中最重要的一个组件, Activity如何被启动和如何被组合也是 Android app 模型中最基本的一部分, Android 系统将在应用的特定生命期阶段, 调用特定的回调方法. Android 中的回调方法全部以on开头 每个 app 都以数个Activity松散地组合, 这种设计模式使得每个Activity都可以作为被其他应用调用的入口 这使得 Android app 既可以给予用户一个完整的应用体验, 又可以被单独地抽取一些页面作为其他应用的工具来使用 参考 谷歌官方指南-组件-Activity篇 Lemon_95 简书博客 Android 四大组件 继承结构 java.lang.Object ↳ android.content.Context ↳ android.content.ContextWrapper ↳ android.view.ContextThemeWrapper ↳ android.app.Activity 生命周期 onCreate() -&gt; onStart() - &gt; onResume() -&gt; onPause() -&gt; onStop() -&gt; onDestroy() 至于具体的回调顺序, google官方有非常棒的图示, 我这里直接引用官方原图 下面时对各个回调方法进行的简单描述 onCreate() -&gt; onDestroy() 整个生命期 onCreate() 在 Activity 首次被创建时调用 应该在这里 执行全局状态设置 例如: 定义与绑定布局, 创建必要的网络连接线程, onDestroy() 在 Activity 被销毁时调用 应该在这里 释放所有的资源 例如: 注销之前创建的 “全局” 广播接收器, 停止创建的网络线程 onStart() -&gt; onStop() 可见生命期onStart()调用完成后, 意味着程序已经准备好与用户交互, 但需要等待进入前台才能开始交互, 这意味着 onStart() 在 Activity 即将对用户可见之前调用 可以在这里 注册关于监听UI变化的广播接收器 onStop() 在 Activity 对用户不再可见时调用 onResume() -&gt; onPause() 前台生命期 onResume() 在 Activity 即将开始与用户进行交互之前调用 onCreateOptionsMenu在这之后调用 应该在这里 开启动画, 打开本活动需要使用的一些设备(如照相机) onPause() 当系统即将开始继续另一个 Activity 时调用 注意: 弹出dialog对话框时, onPause()不会被回调 应该在这里 确认对未保存的持久性数据的更改, 停止动画以及其他可能消耗 CPU 的内容, 这里的操作需要被非常迅速地完成 异常情形下的生命周期异常情况下 Activity 会被销毁并重新创建 异常情形1: 资源相关的系统配置改变 例如 屏幕旋转. 如果想避免活动被销毁重建, 可以对清单文件进行如下设置 1android:configChanges=\"orientation|screenSize\" 如果不进行设置来覆盖默认操作, 在销毁重建时, activity 依次调用 &gt; `onCreate -&gt; onStart -&gt; onResume-&gt;onPause -&gt; 保存状态 onSaveInstanceState -&gt; onStop -&gt; 销毁 onDestroy -&gt; 重新创建 onCreate -&gt; onStart -&gt; 恢复之前保存的状态 onRestoreInstanceState -&gt; onResume` ​ *引用自 https://bbs.csdn.net/topics/392319812* 其中`onRestoreInstanceState`被保证在`onStop`之前被调用, 并留下一个`Bundle`作为`onCreate`和`onRestoreInstanceState`的传参 `view`和`activity`一样都有`onSaveInstanceState`和`onRestoreInstanceState`方法, 都用于之前状态的恢复, 例如: `EditView`会恢复用户输入的数据, `ListView`会恢复滚动的位置 异常情形2: 内存不足导致低优先级的activity被销毁 activity的优先级从高到低可分为以下三种 前台activity 正在与用户进行交互的activity 可见但非前台 activity 非前台的activity弹出了一个dialog 后台activity 执行了onStop但未执行onDestroy 启动模式看上去不是很重要, 主要就是定义在一些情况下activity的复用情况, 用到时查下百度就好, 就不在此罗列了 Service(作为四大组件之一, 我至今都没有用过, 学的是个什么 Android 啊……) Service是一个可以在后台执行长时间运行操作, 但不提供用户界面的应用组件 其他组件可以绑定到相应的服务, 甚至进行进程间通信(IPC Inter-Process Communication 不同进程之间通过共享内存区, 或者磁盘上的普通文件传播或交换信息) 服务最常见的作用: 处理网络事务, 播放音乐, 执行文件I/O, 与内容提供程序交互 参考 谷歌官方指南-组件-Service篇 继承结构 java.lang.Object ↳ android.content.Context ↳ android.content.ContextWrapper ↳ android.app.Service 使用服务还是线程?由于服务是一种即使用户未与应用交互也可以在后台运行的组件, 秉承奥卡姆剃刀原理, 应该只在必要时才创建服务 如果需要在主线程外执行工作, 不过仅仅与用户交互时才有需要, 应该创建新线程 注意! 在默认情况下, 服务仍在应用的主线程中运行 如果需要服务实现密集型或阻止性操作 (例如 MP3 播放或联网) , 仍应在服务内创建新线程, 使主线程专注于前台 Activity 与用户的交互 Service 的两种形式启动应用组件通过 调用startService()启动服务时, 服务处于启动状态, 一旦启动, 服务可在后台无期限运行, 直到被指派的事务被完成 这种Service通常执行的是单一操作, 而且不会将结果返回给调用方. 例如: 点击下载链接后, 浏览器在后台下载文件 绑定","link":"/2019/04/30/又遇四大组件/"}],"tags":[{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Android","slug":"Android","link":"/tags/Android/"}],"categories":[]}